// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blockUser = `-- name: BlockUser :exec
UPDATE users
SET 
    blocked_until = $2,
    failed_attempts = failed_attempts + 1,
    last_failed_attempt = CURRENT_TIMESTAMP
WHERE email = $1
`

type BlockUserParams struct {
	Email        string             `json:"email"`
	BlockedUntil pgtype.Timestamptz `json:"blocked_until"`
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) error {
	_, err := q.db.Exec(ctx, blockUser, arg.Email, arg.BlockedUntil)
	return err
}

const createLoginAttempt = `-- name: CreateLoginAttempt :exec
INSERT INTO login_attempts (email, success, attempted_at)
VALUES ($1, $2, $3)
`

type CreateLoginAttemptParams struct {
	Email       string             `json:"email"`
	Success     bool               `json:"success"`
	AttemptedAt pgtype.Timestamptz `json:"attempted_at"`
}

func (q *Queries) CreateLoginAttempt(ctx context.Context, arg CreateLoginAttemptParams) error {
	_, err := q.db.Exec(ctx, createLoginAttempt, arg.Email, arg.Success, arg.AttemptedAt)
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (user_id, token, expires_at)
VALUES ($1, $2, $3)
`

type CreateRefreshTokenParams struct {
	UserID    int64              `json:"user_id"`
	Token     string             `json:"token"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createRefreshToken, arg.UserID, arg.Token, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username,
    firstname,
    lastname,
    email,
    password_hash,
    two_fa_enabled
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, username, firstname, lastname, email, password_hash, two_fa_enabled, created_at, updated_at, blocked_until, failed_attempts, last_failed_attempt
`

type CreateUserParams struct {
	Username     string      `json:"username"`
	Firstname    string      `json:"firstname"`
	Lastname     string      `json:"lastname"`
	Email        string      `json:"email"`
	PasswordHash string      `json:"password_hash"`
	TwoFaEnabled pgtype.Bool `json:"two_fa_enabled"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Firstname,
		arg.Lastname,
		arg.Email,
		arg.PasswordHash,
		arg.TwoFaEnabled,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.PasswordHash,
		&i.TwoFaEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BlockedUntil,
		&i.FailedAttempts,
		&i.LastFailedAttempt,
	)
	return i, err
}

const deleteExpiredRefreshTokens = `-- name: DeleteExpiredRefreshTokens :exec
DELETE FROM refresh_tokens
WHERE expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRefreshTokens)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_tokens 
WHERE token = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteRefreshToken, token)
	return err
}

const getBlockedStatus = `-- name: GetBlockedStatus :one
SELECT blocked_until
FROM users
WHERE email = $1
`

func (q *Queries) GetBlockedStatus(ctx context.Context, email string) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getBlockedStatus, email)
	var blocked_until pgtype.Timestamptz
	err := row.Scan(&blocked_until)
	return blocked_until, err
}

const getFailedLogAttempts = `-- name: GetFailedLogAttempts :one
SELECT COUNT(*) as count 
FROM login_attempts 
WHERE email = $1 
  AND success = false 
  AND attempted_at >= $2
`

type GetFailedLogAttemptsParams struct {
	Email       string             `json:"email"`
	AttemptedAt pgtype.Timestamptz `json:"attempted_at"`
}

func (q *Queries) GetFailedLogAttempts(ctx context.Context, arg GetFailedLogAttemptsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getFailedLogAttempts, arg.Email, arg.AttemptedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecentFailedAttempts = `-- name: GetRecentFailedAttempts :one
SELECT COUNT(*) as count
FROM login_attempts 
WHERE email = $1 
  AND success = false 
  AND attempted_at >= $2
`

type GetRecentFailedAttemptsParams struct {
	Email       string             `json:"email"`
	AttemptedAt pgtype.Timestamptz `json:"attempted_at"`
}

func (q *Queries) GetRecentFailedAttempts(ctx context.Context, arg GetRecentFailedAttemptsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getRecentFailedAttempts, arg.Email, arg.AttemptedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT user_id, expires_at FROM refresh_tokens 
WHERE token = $1 
LIMIT 1
`

type GetRefreshTokenRow struct {
	UserID    int64              `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetRefreshToken(ctx context.Context, token string) (GetRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, token)
	var i GetRefreshTokenRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT 
    id,
    username,
    firstname,
    lastname,
    email,
    password_hash,
    two_fa_enabled,
    created_at,
    blocked_until,
    failed_attempts
FROM users 
WHERE email = $1 
LIMIT 1
`

type GetUserByEmailRow struct {
	ID             int64              `json:"id"`
	Username       string             `json:"username"`
	Firstname      string             `json:"firstname"`
	Lastname       string             `json:"lastname"`
	Email          string             `json:"email"`
	PasswordHash   string             `json:"password_hash"`
	TwoFaEnabled   pgtype.Bool        `json:"two_fa_enabled"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	BlockedUntil   pgtype.Timestamptz `json:"blocked_until"`
	FailedAttempts pgtype.Int4        `json:"failed_attempts"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.PasswordHash,
		&i.TwoFaEnabled,
		&i.CreatedAt,
		&i.BlockedUntil,
		&i.FailedAttempts,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
    id,
    username,
    firstname,
    lastname,
    email,
    password_hash,
    two_fa_enabled,
    created_at,
    blocked_until,
    failed_attempts
FROM users 
WHERE id = $1 
LIMIT 1
`

type GetUserByIDRow struct {
	ID             int64              `json:"id"`
	Username       string             `json:"username"`
	Firstname      string             `json:"firstname"`
	Lastname       string             `json:"lastname"`
	Email          string             `json:"email"`
	PasswordHash   string             `json:"password_hash"`
	TwoFaEnabled   pgtype.Bool        `json:"two_fa_enabled"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	BlockedUntil   pgtype.Timestamptz `json:"blocked_until"`
	FailedAttempts pgtype.Int4        `json:"failed_attempts"`
}

func (q *Queries) GetUserByID(ctx context.Context, id int64) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.PasswordHash,
		&i.TwoFaEnabled,
		&i.CreatedAt,
		&i.BlockedUntil,
		&i.FailedAttempts,
	)
	return i, err
}

const refreshDeleteByUserI = `-- name: RefreshDeleteByUserI :exec
DELETE FROM refresh_tokens 
WHERE user_id = $1
`

func (q *Queries) RefreshDeleteByUserI(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, refreshDeleteByUserI, userID)
	return err
}

const refreshDeleteByUserID = `-- name: RefreshDeleteByUserID :exec
DELETE FROM refresh_tokens 
WHERE user_id = $1
`

func (q *Queries) RefreshDeleteByUserID(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, refreshDeleteByUserID, userID)
	return err
}

const resetFailedAttempts = `-- name: ResetFailedAttempts :exec
UPDATE users 
SET 
    failed_attempts = 0,
    blocked_until = NULL 
WHERE email = $1
`

func (q *Queries) ResetFailedAttempts(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, resetFailedAttempts, email)
	return err
}

const updatePasswordHash = `-- name: UpdatePasswordHash :exec
UPDATE users 
SET password_hash = $2
WHERE id <= $1
`

type UpdatePasswordHashParams struct {
	ID           int64  `json:"id"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdatePasswordHash(ctx context.Context, arg UpdatePasswordHashParams) error {
	_, err := q.db.Exec(ctx, updatePasswordHash, arg.ID, arg.PasswordHash)
	return err
}

const updateTwoFAStatus = `-- name: UpdateTwoFAStatus :exec
UPDATE users
SET two_fa_enabled = $2
WHERE id = $1
`

type UpdateTwoFAStatusParams struct {
	ID           int64       `json:"id"`
	TwoFaEnabled pgtype.Bool `json:"two_fa_enabled"`
}

func (q *Queries) UpdateTwoFAStatus(ctx context.Context, arg UpdateTwoFAStatusParams) error {
	_, err := q.db.Exec(ctx, updateTwoFAStatus, arg.ID, arg.TwoFaEnabled)
	return err
}
